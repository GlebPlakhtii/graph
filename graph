#include <iostream>
#include <fstream>

using namespace std;
struct Graph;

void matrix_init(Graph &grp);

void fill_matrix(Graph &grp);

void show_matrix(int **, int);

void adj_list(Graph &grp, int node) ;

int ** get_edges(Graph &grp);

void reachability(Graph &grp);



struct Graph {
    int e_size = 0;
    int v_size = 0;
    int **matrix{};


};

int main() {
    Graph grp;
    grp.v_size = 9;
    matrix_init(grp);
    fill_matrix(grp);
    cout<<"W0:"<<endl;
    show_matrix(grp.matrix, grp.v_size);
    cout<<endl;


    reachability(grp);

}




void matrix_init(Graph &grp) {
    grp.matrix = new int *[grp.v_size];
    for (int i = 0; i < grp.v_size; i++) {
        grp.matrix[i] = new int[grp.v_size];
    }
}

void fill_matrix(Graph &grp) {
    int tmp;
    ifstream fin("/home/hleb/CLionProjects/Graph/input.txt");
    for (int i = 0; i < grp.v_size; i++) {
        for (int j = 0; j < grp.v_size; j++) {
            fin >> tmp;
            grp.matrix[i][j] = tmp;

            if (tmp == 1)
                grp.e_size++;


        }
    }
    grp.e_size /= 2;
    fin.close();


}

void show_matrix(int **matrix, int size) {
    for (int i = 0; i < size; i++) {
        for (int j = 0; j < size; j++) {

            cout << matrix[i][j] << " ";


        }
        cout << endl;
    }

}

void adj_list(Graph &grp, int node) {
    int j = 0;
    node--;
    int *adj_list_tmp = new int[grp.v_size];
    for (int i = 0; i < grp.v_size; ++i) {
        if (grp.matrix[node][i] == 1) {
            adj_list_tmp[j] = i+1;
            j++;

        }

    }

    cout<<endl;


    for (int i = 0; i < j; ++i) {
        cout<<adj_list_tmp[i]<<" ";

    }
    cout<<endl;




}
int ** get_edges(Graph &grp){
    int** edges=new int*[grp.e_size];
    for (int j = 0; j < grp.e_size; ++j) {
        edges[j]=new int[2];
    }

    int t=0;
    for (int i = 0; i < grp.v_size; ++i) {
        for (int j = 0; j < grp.v_size; ++j) {
                if(grp.matrix[i][j]==1 && i<j ) {
                    edges[t][0] = i + 1;
                    edges[t][1] = j + 1;

                    t++;


                }





        }
    }
    return edges;
}

void reachability(Graph &grp){
    int***reach_matrix=new int **[grp.v_size];
    for (int i = 0; i < grp.v_size; ++i) {
        reach_matrix[i]=new int*[grp.v_size];
        for (int j = 0; j <grp.v_size; ++j) {
            reach_matrix[i][j]=new int[grp.v_size];
        }
        reach_matrix[0]=grp.matrix;

    }
    for (int k = 1; k < grp.v_size; ++k) {
        for (int i = 0; i <grp.v_size; ++i) {
            for (int j = 0; j < grp.v_size; ++j) {
                if((reach_matrix[k-1][i][j])||(reach_matrix[k-1][i][k-1] && reach_matrix[k-1][k-1][j])) {
                    reach_matrix[k][i][j] = 1;
                }




            }

        }cout<<"W"<<k<<endl;
        show_matrix(reach_matrix[k],grp.v_size);
        cout<<endl;

    }





}
